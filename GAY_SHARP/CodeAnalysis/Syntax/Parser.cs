namespace GAY_SHARP.CodeAnalysis.Syntax;public sealed class Parser{    private readonly SyntaxToken[] _tokens;    private int _position;    private SyntaxToken NextToken()    {        var current = Current;        _position++;        return current;    }    public Parser(string text)    {        var tokens = new List<SyntaxToken>();        var lexer = new Lexer(text);        SyntaxToken token;        do        {            token = lexer.NextToken();            if (token.Kind != SyntaxKind.WhiteSpaceToken && token.Kind != SyntaxKind.BadToken)            {                tokens.Add(token);            }        } while (token.Kind != SyntaxKind.EndOfFileToken);        _tokens = tokens.ToArray();    }    private SyntaxToken Peek(int offset)    {        var index = _position + offset;        return index >= _tokens.Length ? _tokens[^1] : _tokens[index];    }    private SyntaxToken Current => Peek(0);    private SyntaxToken MatchTokens(SyntaxKind kind)    {        return Current.Kind == kind ? NextToken() : new SyntaxToken(kind, Current.Position, null, null);    }    public SyntaxTree Parse()    {        var expression = ParseExpression();        var endOfFileToken = MatchTokens(SyntaxKind.EndOfFileToken);        return new(expression, endOfFileToken);    }    private ExpressionSyntax ParseExpression(int parentPrecedence = 0)    {        ExpressionSyntax left;        var unaryOperator = Current.Kind.GetUnaryOperatorPrecedence();        if (unaryOperator != 0 && unaryOperator >= parentPrecedence)        {            var operatorToken = NextToken();            var operand = ParseExpression(unaryOperator);            left = new UnaryExpressionSyntax(operatorToken, operand);        }        else            left = ParsePrimaryExpression();        while (true)        {            var precedence = Current.Kind.GetBinaryOperatorPrecedence();            if (precedence == 0 || precedence <= parentPrecedence)                break;            var operatorToken = NextToken();            var right = ParseExpression(precedence);            left = new BinaryExpressionSyntax(left, operatorToken, right);        }        return left;    }    private ExpressionSyntax ParsePrimaryExpression()    {        if (Current.Kind == SyntaxKind.OpenParenthesisToken)        {            var left = NextToken();            var expression = ParseExpression();            var right = MatchTokens(SyntaxKind.CloseParenthesisToken);            return new ParenthesizedExpressionSyntax(left, expression, right);        }        var numberToken = MatchTokens(SyntaxKind.NumberToken);        return new LiteralExpressionSyntax(numberToken);    }}